package main

import (
	"encoding/base64"
	"testing"

	"github.com/aws/aws-sdk-go/service/kms"
	"github.com/aws/aws-sdk-go/service/kms/kmsiface"
)

type s3ClientMock struct {
}

func (c *s3ClientMock) GetValue(path string) (string, error) {
	return path + " value", nil
}

func TestGetValue(t *testing.T) {
	cli := &s3ClientMock{}
	envMap := map[string]string{
		"ABC": "path/to/ABC",
		"DEF": "path/to/DEF",
	}
	res, err := getValues(cli, envMap)
	if err != nil {
		t.Fatalf("err: %s", err)
	}
	if len(res) != 2 {
		t.Fatalf("expected 2, actual: %d", len(res))
	}
	if res["ABC"] != "path/to/ABC value" {
		t.Fatalf("expected \"path/to/ABC value\", actual: %s", res["ABC"])
	}
	if res["DEF"] != "path/to/DEF value" {
		t.Fatalf("expected \"path/to/DEF value\", actual: %s", res["DEF"])
	}
}

type kmsMock struct {
	kmsiface.KMSAPI
	resp kms.DecryptOutput
}

func (c kmsMock) Decrypt(in *kms.DecryptInput) (*kms.DecryptOutput, error) {
	return &c.resp, nil
}

func TestResolveTransit(t *testing.T) {
	// these are generated by KMS and Barcelona server
	body := "bcn:transit:v1:AQIDAHjwH8NGFSVXT6dKwt1t//vHud4XVwBVDudijlGJdIxcJgHipzarZN96F0d/5t2TX4XDAAAAfjB8BgkqhkiG9w0BBwagbzBtAgEAMGgGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMSSkfboVY0/dqEaHiAgEQgDsC65jqmWIXzVzOdR5IP496AWDwoQ6BqsIaDgvykSPiUV+aTbj55HlimueT71MJtRGaylVzNlwb/uP5wQ==:9mYhVj1UYdly6xdDGywtnkYu8SiZNRWfU5oHZppMoJAKu0ZK6sfknA=="
	plaintextDataKey := "HMba8i8J+V4NTCuvsBtVejbwtzv/CPh9yfqJ054lbCI="

	dataKeyBlob, err := base64.StdEncoding.DecodeString(plaintextDataKey)
	if err != nil {
		t.Fatalf("err: %s", err)
	}

	resolver := &TransitResolver{
		kmsCli: kmsMock{resp: kms.DecryptOutput{Plaintext: dataKeyBlob}},
		region: "ap-northeast-1",
	}
	key, value, err := resolver.ResolveSecret("__BCN_SECRET__ENV_VAR_NAME", body)

	if err != nil {
		t.Fatalf("err: %s", err)
	}

	if key != "ENV_VAR_NAME" {
		t.Fatalf("expected ENV_VAR_NAME, actual: %s", key)
	}

	if value != "thisissecret" {
		t.Fatalf("expected \"thisissecret\", actual: %s", value)
	}
}

func TestNonTransit(t *testing.T) {
	body := "unencrypted value"
	resolver := &TransitResolver{
		kmsCli: kmsMock{resp: kms.DecryptOutput{Plaintext: []byte("")}},
		region: "ap-northeast-1",
	}
	key, value, err := resolver.ResolveSecret("ENV_VAR_NAME", body)

	if err != nil {
		t.Fatalf("err: %s", err)
	}

	if key != "ENV_VAR_NAME" {
		t.Fatalf("expected ENV_VAR_NAME, actual: %s", key)
	}

	if value != "unencrypted value" {
		t.Fatalf("expected \"unencrypted value\", actual: %s", value)
	}
}
